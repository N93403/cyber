
## **7. tests/test_malware_analysis.py**
```python
#!/usr/bin/env python3
"""
TEST SUITE FOR MALWARE ANALYSIS PROJECT
Validates analysis tools and safety measures
"""

import unittest
import os
import tempfile
import hashlib
from pathlib import Path
import sys

class TestMalwareAnalysisTools(unittest.TestCase):
    
    def setUp(self):
        """Set up test environment"""
        self.test_dir = Path(tempfile.mkdtemp(prefix="malware_test_"))
        self.sample_files = []
        
    def tearDown(self):
        """Clean up test files"""
        import shutil
        shutil.rmtree(self.test_dir, ignore_errors=True)
    
    def create_test_file(self, content, extension=".bin"):
        """Create a test file with given content"""
        test_file = self.test_dir / f"test_file{len(self.sample_files)}{extension}"
        with open(test_file, 'wb') as f:
            f.write(content)
        self.sample_files.append(test_file)
        return test_file
    
    def test_basic_static_analyzer_import(self):
        """Test that basic static analyzer can be imported"""
        try:
            # Add scripts directory to path
            scripts_dir = Path(__file__).parent.parent / "scripts"
            sys.path.append(str(scripts_dir))
            
            from basic_static_analyzer import BasicStaticAnalyzer
            
            # Test analyzer creation
            test_file = self.create_test_file(b"test content")
            analyzer = BasicStaticAnalyzer(test_file)
            
            self.assertIsNotNone(analyzer)
            self.assertEqual(analyzer.sample_path, test_file)
            
        except ImportError as e:
            self.fail(f"Failed to import basic_static_analyzer: {e}")
    
    def test_file_hashing(self):
        """Test file hash calculation"""
        test_content = b"Educational malware sample content"
        test_file = self.create_test_file(test_content)
        
        # Calculate expected hash
        expected_md5 = hashlib.md5(test_content).hexdigest()
        expected_sha256 = hashlib.sha256(test_content).hexdigest()
        
        # Test using analyzer
        scripts_dir = Path(__file__).parent.parent / "scripts"
        sys.path.append(str(scripts_dir))
        
        from basic_static_analyzer import BasicStaticAnalyzer
        
        analyzer = BasicStaticAnalyzer(test_file)
        analyzer.get_file_signature()
        
        file_info = analyzer.analysis_result.get('file_info', {})
        
        self.assertEqual(file_info.get('md5'), expected_md5)
        self.assertEqual(file_info.get('sha256'), expected_sha256)
        self.assertEqual(file_info.get('file_size'), len(test_content))
    
    def test_entropy_calculation(self):
        """Test entropy calculation for different data patterns"""
        from basic_static_analyzer import BasicStaticAnalyzer
        
        # Low entropy data (repeating pattern)
        low_entropy_data = b"AAAA" * 100
        low_entropy_file = self.create_test_file(low_entropy_data)
        
        analyzer_low = BasicStaticAnalyzer(low_entropy_file)
        analyzer_low.get_file_signature()
        low_entropy = analyzer_low.analysis_result['file_info']['entropy']
        
        # High entropy data (random)
        high_entropy_data = os.urandom(400)
        high_entropy_file = self.create_test_file(high_entropy_data)
        
        analyzer_high = BasicStaticAnalyzer(high_entropy_file)
        analyzer_high.get_file_signature()
        high_entropy = analyzer_high.analysis_result['file_info']['entropy']
        
        # High entropy should be greater than low entropy
        self.assertGreater(high_entropy, low_entropy)
        self.assertLess(low_entropy, 2.0)  # Very low entropy for repeating data
        self.assertGreater(high_entropy, 7.0)  # High entropy for random data
    
    def test_string_extraction(self):
        """Test string extraction from binary data"""
        from basic_static_analyzer import BasicStaticAnalyzer
        
        # Create file with embedded strings
        test_content = b"Normal text\x00Suspicious http://example.com\x00System32\\cmd.exe\x00"
        test_file = self.create_test_file(test_content)
        
        analyzer = BasicStaticAnalyzer(test_file)
        analyzer.analyze_strings(min_length=4)
        
        strings_info = analyzer.analysis_result.get('strings', {})
        
        self.assertGreater(strings_info.get('total_strings', 0), 0)
        self.assertGreater(strings_info.get('suspicious_count', 0), 0)
        
        # Check if suspicious strings were detected
        suspicious_found = any(
            'http://' in string or 'cmd.exe' in string
            for string in strings_info.get('suspicious_strings', [])
        )
        self.assertTrue(suspicious_found)
    
    def test_yara_rule_loading(self):
        """Test YARA rule loading functionality"""
        from basic_static_analyzer import BasicStaticAnalyzer
        
        # Create a simple YARA rule file for testing
        yara_rules_dir = self.test_dir / "yara_rules"
        yara_rules_dir.mkdir()
        
        test_rule = """
rule TestRule {
    strings:
        $test_string = "TEST_SIGNATURE"
    condition:
        $test_string
}
"""
        rule_file = yara_rules_dir / "test_rule.yar"
        with open(rule_file, 'w') as f:
            f.write(test_rule)
        
        # Create test file that matches the rule
        test_content = b"Some data TEST_SIGNATURE more data"
        test_file = self.create_test_file(test_content)
        
        analyzer = BasicStaticAnalyzer(test_file)
        rules_loaded = analyzer.load_yara_rules(str(yara_rules_dir))
        
        self.assertTrue(rules_loaded)
        self.assertIsNotNone(analyzer.yara_rules)
    
    def test_suspicion_scoring(self):
        """Test suspicion score calculation"""
        from basic_static_analyzer import BasicStaticAnalyzer
        
        # Create test file
        test_file = self.create_test_file(b"test content")
        
        analyzer = BasicStaticAnalyzer(test_file)
        
        # Mock analysis results
        analyzer.analysis_result = {
            'file_info': {'entropy': 7.8},  # High entropy
            'strings': {'suspicious_count': 15},  # Many suspicious strings
            'pe_analysis': {
                'suspicious_imports': ['VirtualAlloc', 'CreateRemoteThread', 'WriteProcessMemory']
            }
        }
        
        analyzer.generate_suspicion_score()
        
        score = analyzer.analysis_result.get('suspicion_score', 0)
        risk_level = analyzer.analysis_result.get('risk_level', 'UNKNOWN')
        
        self.assertGreater(score, 0)
        self.assertIn(risk_level, ['LOW', 'MEDIUM', 'HIGH', 'VERY LOW'])
    
    def test_analysis_report_generation(self):
        """Test that analysis reports can be generated"""
        from basic_static_analyzer import BasicStaticAnalyzer
        
        test_file = self.create_test_file(b"sample content for report testing")
        
        analyzer = BasicStaticAnalyzer(test_file)
        analyzer.analysis_result = {
            'file_info': {
                'filename': 'test.exe',
                'file_size': 1000,
                'md5': 'test_md5',
                'sha256': 'test_sha256',
                'entropy': 6.5
            },
            'strings': {
                'total_strings': 10,
                'suspicious_count': 2,
                'suspicious_strings': ['http://bad.com', 'cmd.exe']
            },
            'suspicion_score': 45,
            'risk_level': 'MEDIUM',
            'risk_factors': ['High entropy', 'Suspicious strings']
        }
        
        # Test that print_report doesn't crash
        try:
            analyzer.print_report()
            report_success = True
        except Exception as e:
            report_success = False
            print(f"Report generation failed: {e}")
        
        self.assertTrue(report_success)

class TestSafetyMeasures(unittest.TestCase):
    """Test safety measures and environment checks"""
    
    def test_virtualization_detection(self):
        """Test virtualization detection (if available)"""
        try:
            import subprocess
            result = subprocess.run(['systemd-detect-virt'], 
                                 capture_output=True, text=True)
            # If command exists and returns successfully, we're likely in a VM
            if result.returncode == 0:
                print(f"Running in: {result.stdout.strip()}")
                self.assertTrue(True)  # VM detected
            else:
                self.assertTrue(True)  # Command not available, but test passes
        except:
            self.assertTrue(True)  # Command failed, but test passes
    
    def test_analysis_directory_structure(self):
        """Test that analysis directory structure is correct"""
        project_root = Path(__file__).parent.parent
        
        required_dirs = [
            'samples',
            'scripts', 
            'docs',
            'tests',
            'reports',
            'tools'
        ]
        
        for dir_name in required_dirs:
            dir_path = project_root / dir_name
            self.assertTrue(dir_path.exists(), f"Required directory missing: {dir_name}")
    
    def test_no_real_malware_in_repo(self):
        """Ensure no real malware samples are in repository"""
        project_root = Path(__file__).parent.parent
        
        # Check samples directory for real malware warnings
        samples_dir = project_root / "samples" / "malicious" / "real"
        if samples_dir.exists():
            # Should contain only README, no actual samples
            files = list(samples_dir.glob("*"))
            self.assertEqual(len(files), 1)  # Only README
            if files:
                self.assertEqual(files[0].name, "README.txt")
    
    def test_configuration_files(self):
        """Test that configuration files exist and are valid"""
        project_root = Path(__file__).parent.parent
        
        config_files = [
            'config/analysis.conf'
        ]
        
        for config_file in config_files:
            config_path = project_root / config_file
            if config_path.exists():
                # Basic syntax check - file can be read
                try:
                    with open(config_path, 'r') as f:
                        content = f.read()
                    self.assertGreater(len(content), 0)
                except Exception as e:
                    self.fail(f"Config file {config_file} is invalid: {e}")

def run_safety_checks():
    """Run additional safety checks outside of unit tests"""
    print("üîí RUNNING SAFETY CHECKS")
    print("=" * 50)
    
    checks_passed = 0
    total_checks = 0
    
    # Check 1: Virtualization
    total_checks += 1
    try:
        import subprocess
        result = subprocess.run(['systemd-detect-virt'], 
                             capture_output=True, text=True)
        if result.returncode == 0:
            print(f"‚úÖ Running in VM: {result.stdout.strip()}")
            checks_passed += 1
        else:
            print("‚ö†Ô∏è  Not detected as virtualized environment")
    except:
        print("‚ö†Ô∏è  Could not detect virtualization")
    
    # Check 2: Network isolation
    total_checks += 1
    try:
        import socket
        # Try to connect to a test address
        test_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        test_socket.settimeout(1)
        try:
            test_socket.connect(("8.8.8.8", 53))
            print("‚ö†Ô∏è  Network connectivity detected")
        except:
            print("‚úÖ Network appears isolated")
            checks_passed += 1
        finally:
            test_socket.close()
    except:
        print("‚ö†Ô∏è  Could not check network isolation")
    
    # Check 3: Analysis tools availability
    total_checks += 1
    try:
        from basic_static_analyzer import BasicStaticAnalyzer
        print("‚úÖ Analysis tools available")
        checks_passed += 1
    except ImportError as e:
        print(f"‚ùå Analysis tools not available: {e}")
    
    print(f"\nüìä SAFETY CHECKS: {checks_passed}/{total_checks} passed")
    
    if checks_passed == total_checks:
        print("üéâ All safety checks passed!")
    else:
        print("‚ö†Ô∏è  Some safety checks failed - proceed with caution")

if __name__ == "__main__":
    # Run safety checks first
    run_safety_checks()
    print("\n" + "=" * 50)
    
    # Run unit tests
    print("üß™ RUNNING UNIT TESTS")
    unittest.main(verbosity=2)
